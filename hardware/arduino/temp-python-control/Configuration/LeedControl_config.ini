# Configuration File for ReadArdo.py
#####################

[communication_bytes]
#communication byte to communicate with the Arduino. If changes are done here
#   changes have also to be done on Arduino side
# -----------------------------------------
#STARTMARKER: marks the start of a message (int, 0-255)
#ENDMARKER:  marks the end of a message (int, 0-255)
#SPECIAL_BYTE: encodes/decodes if one byte in message is a STARTMARKER, 
#   ENDMARKER or a SPECIAL_BYTE. It encodes this msg_byte with 2 bytes, 
#   first is the SPECIAL_BYTE, second is SPECIAL_BYTE - msg_byte (int, 0-255)
#PC_CONFIGURATION: byte to test connection and get hardware (int, 0-255)
#PC_SET_UP_ADCS: byte to initialise the adc (int, 0-255)
#PC_OK: byte to send a okay, that a procedure has finished on the arduino
#   (int, 0-255)
#	!!!!!!!!!!! ONLY FOR NOW: Every PC_OK has a PC_ERROR as it's counterpart
#PC_TRIGGER_ADCS: byte to initialise adc measurements (int, 0-255)
#PC_RESET: byte to reset the arduino (int, 0-255)
#PC_SET_VOLTAGE: byte to initialise the dac (int, 0-255)
#PC_AUTOGAIN: byte to initialise the autogain (int, 0-255)
#PC_CALIBRATION: byte to start the calibration
#PC_ERROR: byte which gets sent if an error occurred, serves as an indicator
#	that the next next message will contain the trace back byte (error_bytes)
STARTMARKER = 254
ENDMARKER = 255
SPECIAL_BYTE = 252
PC_CONFIGURATION = 63
PC_SET_UP_ADCS = 83
PC_OK = 75
PC_TRIGGER_ADCS = 84
PC_RESET = 82
PC_SET_VOLTAGE = 86 
PC_AUTOGAIN = 65
PC_ERROR = 253
PC_CALIBRATION = 67

[hardware_bits]
#contains the identification values of the respective hardware parts which
#   are used in the bitmask
#NAME: 0xValueInHex Description when bit is set
#ADC_0_PRESENT:  0x01 Bit is set if ADC #0 was detected
#ADC_1_PRESENT:  0x02 Bit is set if ADC #1 was detected
#LM35_PRESENT:   0x04 Bit is set if LM35 temperature sensor was detected
#RELAY_PRESENT:  0x08 Bit is set if the relay for I0 input 2.5V/10V is present
#JP_I0_CLOSED:   0x10 Bit is set if JP3 7-8 is closed or relay on (to indicate 2.5V I0 range)
#JP_AUX_CLOSED:  0x20 Bit is set if JP5 is closed (to indicate 2.5V AUX range rather than 10V range)
ADC_0_PRESENT = 1
ADC_1_PRESENT = 2
LM35_PRESENT = 4
RELAY_PRESENT = 8
JP_I0_CLOSED = 16
JP_AUX_CLOSED = 32

[error_bytes]
#error bytes which serve to identify which kind of error occurred
#ERROR_NO_ERROR: No error
#ERROR_SERIAL_OVERFLOW: Hardware overflow of Arduino serial
#ERROR_MSG_TOO_LONG: Too many characters in message from PC
#ERROR_MSG_INCONSITENT: Message received from PC is inconsistent. Probably corrupt.
#ERROR_MSG_UNKNOWN: Unknown request from PC
#ERROR_MSG_DATA_INVALID: Request from PC contains invalid information
#ERROR_NEVER_CALIBRATED: The ADCs have never been calibrated before since bootup
#ERROR_TIMEOUT: Timed out while waiting for something
#ERROR_ADC_SATURATED: One of the ADC values reached saturation, and gain can't be decreased further
#ERROR_TOO_HOT: The temperature read by the LM35 is too high
#ERROR_RUNTIME: Some function has been called from an inappropriate state. This is to flag possible bugs for future development.
ERROR_NO_ERROR = 0
ERROR_SERIAL_OVERFLOW = 1
ERROR_MSG_TOO_LONG = 2
ERROR_MSG_INCONSITENT = 3
ERROR_MSG_UNKNOWN = 4
ERROR_MSG_DATA_INVALID = 5
ERROR_NEVER_CALIBRATED = 6
ERROR_TIMEOUT = 7
ERROR_ADC_SATURATED = 8
ERROR_TOO_HOT = 9
ERROR_RUNTIME = 255

[adc_start_configuration]
#The configuration of the ADCs at the start of the measurements
# -----------------------------------------
#channels: Channel selection for the ADCs, possible values are 0 and 1
#update_rate: when suppling the adc with a master clock of 4,9MHz, allowed 
#   update rates are: 4 (50Hz), 5 (60Hz), 6 (250Hz), 7 (500Hz).
#measurement_counter: Number of measurments done before sending the value 
#   to the computer. The adc values are sumed up and divided with 
#   the measurement_counter to get the mean value. Value which can be cast to
#   int. Allowed values are from 0 - (2**16 - 1)
#maximum_gain: highest gain allowed, allowed values from 0 - 7,
#   value which can be cast to int
# -----------------------------------------
adc0_channel = 0
adc1_channel = 0
update_rate = 4
measurement_counter = 10
maximum_gain = 7

[adc_autogain_configuration]
#The configuration of the ADCs before the autogain is done
# -----------------------------------------
#channels: Channel selection for the ADCs, possible values are 0 and 1
#update_rate: when suppling the adc with a master clock of 4.9MHz, allowed 
#   update rates are: 4 (50Hz), 5 (60Hz), 6 (250Hz), 7 (500Hz).
#measurement_counter: Number of measurements done before taking the value for 
#   configuring the right gain. The adc values are summed up and divided with 
#   the measurement_counter to get the mean value. Value which can be cast to
#   int. 
#maximum_gain: highest gain allowed, allowed values from 0 - 7,
#   value which can be cast to int
# -----------------------------------------
adc0_channel = 0
adc1_channel = 0
update_rate = 7
measurement_counter = 10
maximum_gain = 7


[measurement_settings]
#Settings of measurement
# -----------------------------------------
#energy_max: Maximum energy of DAC in Volt, value that can be cast to float
#dac_settle_time: settle time for the dac, before starting the measurement 
#    the adc. Value in milliseconds which can be cast to int. 
#dac_first_settle_time: settle time for the dac, when the first value is set
#   to the dac. Value in milliseconds which can be cast to int.
#v_ref_adc: Reference voltage of adc, has to be measured directly at the adc, 
#   value in volt, that can be cast to float
#v_ref_dac: Reference voltage of dac, has to be measured directly at the dac
#   value in volt, that can be cast to float
#path: Path to the directory for the csv files with the measurement datas. 
# -----------------------------------------
energy_max = 5
dac_settle_time = 100
dac_first_settle_time = 20000
dac_value_end = 0
v_ref_adc = 2.56
v_ref_dac = 2.5
path = E:\Work\Vienna\SPECSLab\Technical\Upgrades\Python LEED-IV\00 Measure - BernhardMayr\LEED_Package_Version1.0\LeedControl_Python3.7\LEED_measurements
# TODO: Check if v_ref values are correct

[leed_hardware]
#contains information regarding the experimental setup for the LEED measurements
I0_conversion_factor = 1
#Microamps per Volt

[camera_settings]
# -----------------------------------------
#class_name: is the class name of the camera
#device_name: is the name to look for in the device list of the connections
#camera_settle_time: defines the time between a new value at the dac and a new 
#   image shot
#video_format: defines the video format. The first string (Y16) describes the 
#   sink format (16 bit, monochrome). The second string gives horizontal x 
#   vertical. Allowed values for DMK 33GX265 are minimum 528x4 and maximum
#   2048x1536. The first number has to be a multiple of 16 and the second a 
#   multiple of 4. 
#set_roi: enables roi, moves the frame within the full resolution
#roi_x,roi_y : horizontal and vertical distance from top-left corner in pixel
#live_mode: enables live mode to see a live stream of the measurements
#exposure_time: in milliseconds, allowed values from 0.02 - 30000, value that 
#   can be cast to float
#gain: in dB, allowed values from 0 - 48 value that can be cast to int
#n_frames: frames to stock in one trigger shot, any value that can be cast to 
#   int.
#frame_rate: frame_rate for live mode, any value that can be cast to int
#image_path: Path to the image directory
#file_name: File prefix, any value that can be cast to string  -> this will need to be adapted depending on the parameters (perhaps)

class_name = ImagingSourceDMKCamera
device_name = DMK 33GX265
camera_settle_time = 0
#TODO: check if necessary (was 50 before we set it to 0) right now it waits after the voltage was already set by the arduino
video_format = Y16 (1536x1536)
set_roi = False
roi_x = 0
roi_y = 0
bin_factor = 3
live_mode = False
exposure_time = 200
gain = 10
n_frames = 1
frame_rate = 10.0
image_path = E:\Work\Vienna\SPECSLab\Technical\Upgrades\Python LEED-IV\00 Measure - BernhardMayr\LEED_Package_Version1.0\LeedControl_Python3.7\LEED_images
file_name = 2020-10-23_DMX265_Exp=200-Gain=0
