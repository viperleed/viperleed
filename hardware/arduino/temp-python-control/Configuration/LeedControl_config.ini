# Configuration File for ReadArdo.py
#####################

[firmware_version]
#CURRETLY v0.1
#Serves to identify the version and ensure compatibility
#FIRMWARE_VERSION_MAJOR/FIRMWARE_VERSION_MINOR: max 255
FIRMWARE_VERSION = 0.1

[communication_bytes]
#communication byte to communicate with the Arduino. If changes are done here
#   changes have also to be done on Arduino side
# -----------------------------------------
#STARTMARKER: marks the start of a message (int, 0-255)
#ENDMARKER:  marks the end of a message (int, 0-255)
#SPECIAL_BYTE: encodes/decodes if one byte in message is a STARTMARKER, 
#   ENDMARKER or a SPECIAL_BYTE. It encodes this msg_byte with 2 bytes, 
#   first is the SPECIAL_BYTE, second is SPECIAL_BYTE - msg_byte (int, 0-255)
#PC_CONFIGURATION: byte to test connection and get hardware (int, 0-255)
#PC_SET_UP_ADCS: byte to initialise the adc (int, 0-255)
#PC_OK: byte to send a okay, that a procedure has finished on the arduino
#   (int, 0-255)
#	!!!!!!!!!!! ONLY FOR NOW: Every PC_OK has a PC_ERROR as it's counterpart
#PC_TRIGGER_ADCS: byte to initialise adc measurements (int, 0-255)
#PC_RESET: byte to reset the arduino (int, 0-255)
#PC_SET_VOLTAGE: byte to initialise the dac (int, 0-255)
#PC_AUTOGAIN: byte to initialise the autogain (int, 0-255)
#PC_CALIBRATION: byte to start the calibration
#PC_ERROR: byte which gets sent if an error occurred, serves as an indicator
#	that the next next message will contain the trace back byte (error_bytes)
STARTMARKER = 254
ENDMARKER = 255
SPECIAL_BYTE = 252
PC_CONFIGURATION = 63
PC_SET_UP_ADCS = 83
PC_OK = 75
PC_RESET = 82
PC_SET_VOLTAGE = 86 
PC_AUTOGAIN = 65
PC_ERROR = 253
PC_CALIBRATION = 67
PC_MEASURE_ONLY = 77

[hardware_bits]
#contains the identification values of the respective hardware parts which
#   are used in the bitmask
#NAME: 0xValueInHex Description when bit is set
#ADC_0_PRESENT:  0x01 Bit is set if ADC #0 was detected
#ADC_1_PRESENT:  0x02 Bit is set if ADC #1 was detected
#LM35_PRESENT:   0x04 Bit is set if LM35 temperature sensor was detected
#RELAY_PRESENT:  0x08 Bit is set if the relay for I0 input 2.5V/10V is present
#JP_I0_CLOSED:   0x10 Bit is set if JP3 7-8 is closed or relay on (to indicate 2.5V I0 range)
#JP_AUX_CLOSED:  0x20 Bit is set if JP5 is closed (to indicate 2.5V AUX range rather than 10V range)
ADC_0_PRESENT = 1
ADC_1_PRESENT = 2
LM35_PRESENT = 4
RELAY_PRESENT = 8
JP_I0_CLOSED = 16
JP_AUX_CLOSED = 32

[error_bytes]
#error bytes which serve to identify which kind of error occurred
#ERROR_NO_ERROR: No error
#ERROR_SERIAL_OVERFLOW: Hardware overflow of Arduino serial
#ERROR_MSG_TOO_LONG: Too many characters in message from PC
#ERROR_MSG_INCONSITENT: Message received from PC is inconsistent. Probably corrupt.
#ERROR_MSG_UNKNOWN: Unknown request from PC
#ERROR_MSG_DATA_INVALID: Request from PC contains invalid information
#ERROR_NEVER_CALIBRATED: The ADCs have never been calibrated before since bootup
#ERROR_TIMEOUT: Timed out while waiting for something
#ERROR_ADC_SATURATED: One of the ADC values reached saturation, and gain can't be decreased further
#ERROR_TOO_HOT: The temperature read by the LM35 is too high
#ERROR_RUNTIME: Some function has been called from an inappropriate state. This is to flag possible bugs for future development.
ERROR_NO_ERROR = 0
ERROR_SERIAL_OVERFLOW = 1
ERROR_MSG_TOO_LONG = 2
ERROR_MSG_INCONSITENT = 3
ERROR_MSG_UNKNOWN = 4
ERROR_MSG_DATA_INVALID = 5
ERROR_NEVER_CALIBRATED = 6
ERROR_TIMEOUT = 7
ERROR_ADC_SATURATED = 8
ERROR_TOO_HOT = 9
ERROR_RUNTIME = 255

[arduino_states]
#STATE_IDLE: Waits for requests from the PC
#STATE_SET_UP_ADCS: Picks correct ADC channels and no. of measurement points
#STATE_SET_VOLTAGE: Sets the voltage with the DAC and triggers the ADCs
#STATE_MEASURE_ADCS: Takes the measurements
#STATE_ADC_VALUES_READY: Returns the measurements to the PC
#STATE_AUTOGAIN_ADCS: Finds optimal gain for both ADCs
#STATE_GET_CONFIGURATION: Finds current hardware configuration and returns it with the firmware version
#STATE_CALIBRATE_ADCS: Figures out the correct offset and calibration factors for the ADCs at all gains.
#STATE_ERROR: Handles errors and returns them
STATE_IDLE = 0
STATE_SET_UP_ADCS = 1
STATE_SET_VOLTAGE = 2
STATE_MEASURE_ADCS = 4
STATE_ADC_VALUES_READY = 5
STATE_AUTOGAIN_ADCS = 6
STATE_GET_CONFIGURATION = 7
STATE_CALIBRATE_ADCS = 8
STATE_ERROR = 9

[iv_movie_configuration]
#The configuration of the ADCs at the start of the measurements
# -----------------------------------------
#channels: Channel selection for the ADCs, possible values are 0 and 1
#measurement_counter: Number of measurments done before sending the value 
#   to the computer. The adc values are sumed up and divided with 
#   the measurement_counter to get the mean value. Value which can be cast to
#   int. Allowed values are from 0 - (2**16 - 1)
# -----------------------------------------
adc0_channel = 0
adc1_channel = 0
measurement_counter = 10

[measure_filament_configuration]
#The configuration of the ADCs at the start of the measurements
# -----------------------------------------
#channels: Channel selection for the ADCs, possible values are 0 and 1
#measurement_counter: Number of measurments done before sending the value 
#   to the computer. The adc values are sumed up and divided with 
#   the measurement_counter to get the mean value. Value which can be cast to
#   int. Allowed values are from 0 - (2**16 - 1)
# -----------------------------------------
adc0_channel = 1
adc1_channel = 0
measurement_counter = 10

[measurement_settings]
#Settings of measurement
# -----------------------------------------
#energy_max: Maximum energy of DAC in Volt, value that can be cast to float
#dac_settle_time: settle time for the dac, before starting the measurement 
#    the adc. Value in milliseconds which can be cast to int. 
#dac_first_settle_time: settle time for the dac, when the first value is set
#   to the dac. Value in milliseconds which can be cast to int.
#v_ref_adc: Reference voltage of adc, has to be measured directly at the adc, 
#   value in volt, that can be cast to float
#v_ref_dac: Reference voltage of dac, has to be measured directly at the dac
#   value in volt, that can be cast to float
#path: Path to the directory for the csv files with the measurement datas. 
#start_energy: energy at which your measurements start
#delta_energy: step size
#end_energy: energy at which your measurements end
# -----------------------------------------
energy_max = 5
dac_settle_time = 100
dac_first_settle_time = 20000
dac_value_end = 0
v_ref_dac = 2.5
path = E:\Work\Vienna\SPECSLab\Technical\Upgrades\Python LEED-IV\00 Measure - BernhardMayr\LEED_Package_Version1.0\LeedControl_Python3.7\LEED_measurements
start_energy = 0.5
delta_energy = 0.005
end_energy = 4.9
# TODO: Check if v_ref values are correct

[leed_hardware]
#contains information regarding the experimental setup for the LEED measurements
I0_conversion_factor = 1
#Microamps per Volt

[camera_settings]
# -----------------------------------------
#class_name: is the class name of the camera
#device_name: is the name to look for in the device list of the connections
#camera_settle_time: defines the time between a new value at the dac and a new 
#   image shot
#video_format: defines the video format. The first string (Y16) describes the 
#   sink format (16 bit, monochrome). The second string gives horizontal x 
#   vertical. Allowed values for DMK 33GX265 are minimum 528x4 and maximum
#   2048x1536. The first number has to be a multiple of 16 and the second a 
#   multiple of 4. 
#set_roi: enables roi, moves the frame within the full resolution
#roi_x,roi_y : horizontal and vertical distance from top-left corner in pixel
#live_mode: enables live mode to see a live stream of the measurements
#exposure_time: in milliseconds, allowed values from 0.02 - 30000, value that 
#   can be cast to float
#gain: in dB, allowed values from 0 - 48 value that can be cast to int
#n_frames: frames to stock in one trigger shot, any value that can be cast to 
#   int.
#frame_rate: frame_rate for live mode, any value that can be cast to int
#image_path: Path to the image directory
#file_name: File prefix, any value that can be cast to string  -> this will need to be adapted depending on the parameters (perhaps)

class_name = ImagingSourceDMKCamera
device_name = DMK 33GX265
camera_settle_time = 0
#TODO: check if necessary (was 50 before we set it to 0) right now it waits after the voltage was already set by the arduino
video_format = Y16 (1536x1536)
set_roi = False
roi_x = 0
roi_y = 0
bin_factor = 3
live_mode = False
exposure_time = 200
gain = 10
n_frames = 1
frame_rate = 10.0
image_path = E:\Work\Vienna\SPECSLab\Technical\Upgrades\Python LEED-IV\00 Measure - BernhardMayr\LEED_Package_Version1.0\LeedControl_Python3.7\LEED_images
file_name = 2020-10-23_DMX265_Exp=200-Gain=0
