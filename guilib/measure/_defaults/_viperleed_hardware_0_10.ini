[energy_calibration]
# Calibration curve for nominal energy.
# ----------------------------------------------------------------
# Use numpy.polynomial.polynomial.polynomial as
# p = Polynomial(coefficients, domain=domain, window=domain). Then
# one should call set_voltage_and_measure(p(desired_true_energy)).
# coefficients = The coefficients of the calibration polynome.
#		f=a+b*x+...  => [a, b, ...]
# domain = The domain used for the fitted polynomial.
# v_ref_dac = The reference voltage of the DAC.
coefficients = [0, 1]
domain = (-10, 1100)
v_ref_dac = 2.5

[measurement_settings]
# i0_settle_time = The time the beam current needs to stabilize in
#		milliseconds. It is the delay time the measurement must wait
#		before triggering any I0 measurements on the controllers.
#		Usually this time is longer than hv_settle_time.
# hv_settle_time = The time the beam energy needs to stabilize in
#		milliseconds. It is the delay time the measurement must wait
#		before triggering any HV measurements on the controllers. It
#		it also the time the measurement must wait before starting
#		acquiring images via the camera(s).
# first_settle_time = The first settle time that is used after setting
#		the first energy in milliseconds. This may be longer that the
#		other settle times as the first time the energy is set the
#		energy step may be significantly larger than any other energy
#		step during that measurement.
# adc_update_rate = The frequency at which the ADCs acquire data. When
#		supplying the ADC with a master clock of 4.9MHz, allowed update
#		rates are = 4 (50Hz), 5 (60Hz), 6 (252.6Hz), 7 (505.3Hz). For
#		more information on this read the doc string in the
#		adc_update_rate section.
# nr_samples = Number of measurements done before sending the value
#		to the computer. The measured adc values are averaged. Allowed
#		values are from 1 to (2**16 - 1) = 65535. Set to 1 for
#		continuous measurements.
i0_settle_time = 2000
hv_settle_time = 1000
first_settle_time = 2000
adc_update_rate = 4
nr_samples = 10

[controller]
# controller_class = Name of the class used for the controller.
# serial_class = Name of the class used for the serial port.
# device_name = Name of the controller.
# port_name = The address under which the controller is found. Has to be
#		determined when selecting the devices that are going to be used.
#		(Can be saved to automatically try to find a device.)
# firmware_version = Version of the firmware these settings apply to.
#		Settings with a firmware version newer than the controller can
#		be used as a substitute for the missing older firmware version
#		settings unless the versions differ in the major.
# measurement_devices = Contains the type of measurements each
#		measuring device can do. 'Aux' is an alternative to
#		'Temperature' in case no thermocouple is connected (in which
#		case also 'Cold_Junction' is probably not useful or not present)
# i0, measured_energy, i_sample, temperature, aux, cold_junction = The
#		ADC channels corresponding to the quantity.
controller_class = ViPErinoController
serial_class = ViPErLEEDSerial
device_name = ViPErLEED ____
port_name = 
firmware_version = 0.10
measurement_devices = (
	('I0', 'Measured_Energy'), ('I_Sample', 'Temperature'), ('Cold_Junction',)
	)
i0 = 0
measured_energy = 1
i_sample = 0
temperature = 1
aux = 1
cold_junction = 0

[conversions]
# This section contains information on which types of conversions are
# to be used to transform the measurements provided by the Arduino
# unit (typically in volts or millivolts) and the physical units.
# ---------------------------------------------------------------
# i0_gain = V/uA in 0--10V range; mV/uA in 0--2.5V range
#     The value returned by the Arduino in the two ranges assumes
#     that (0--10V) 1uA produces 1V at the BNC, or (0--2.5V) 1mA
#     produces 1V at the BNC. This gain factor can be used to account
#     for other situations (e.g., a different resistor is used).
# thermocouple_type = One of the types (e.g., K) for which coefficients
#     are available in classes/thermocouple_coefficients.txt. This is
#     the quantity used to convert the thermoelectric voltage of a
#     thermocouple connected to CH1 of ADC1 (normally AUX), as well as
#     the cold-junction temperature measured by the LM35, into an actual
#     TEMPERATURE in degC.
i0_gain = 1.0
thermocouple_type = None

[hardware_bits]
# Do not edit any of these settings unless you know what you are doing!
# ---------------------------------------------------------------------
# Contains the identification values of the respective hardware parts
#		which are used in the bitmask.
# name = 0xValueInHex Description when bit is set
# adc_0_present = 0x01 Bit is set if ADC #0 was detected.
# adc_1_present = 0x02 Bit is set if ADC #1 was detected.
# lm35_present = 0x04 Bit is set if LM35 temperature sensor was
#		detected.
# relay_present = 0x08 Bit is set if the relay for I0 input 2.5V/10V is
#		present.
# jp_i0_closed = 0x10 Bit is set if JP3 7-8 is closed or relay on (to
#		indicate 2.5V I0 range rather than 10V range).
# jp_aux_closed = 0x20 Bit is set if JP5 is closed (to indicate 2.5V AUX
#		range rather than 10V range).
adc_0_present = 1
adc_1_present = 2
lm35_present = 4
relay_present = 8
jp_i0_closed = 16
jp_aux_closed = 32

[error_bytes]
# Do not edit any of these settings unless you know what you are doing!
# ---------------------------------------------------------------------
# Error bytes which serve to identify which kind of error occurred.
# error_no_error = No error.
# error_serial_overflow = Hardware overflow of Arduino serial.
# error_msg_too_long = Too many characters in message from PC.
# error_msg_inconsistent = Message received from PC is inconsistent.
#		Probably corrupt.
# error_msg_unknown = Unknown request from PC.
# error_msg_data_invalid = Request from PC contains invalid information.
# error_never_calibrated = The ADCs have never been calibrated before
#		since bootup.
# error_timeout = Timed out while waiting for something.
# error_adc_saturated = One of the ADC values reached saturation, and
#		gain can't be decreased further.
# error_too_hot = The temperature read by the LM35 is too high.
# error_hardware_unknown = The PC never asked for the hardware
#		configuration.
# error_runtime = Some function has been called from an inappropriate
#		state. This is to flag possible bugs for future development.
error_no_error = 0
error_serial_overflow = 1
error_msg_too_long = 2
error_msg_inconsistent = 3
error_msg_unknown = 4
error_msg_data_invalid = 5
error_never_calibrated = 6
error_timeout = 7
error_adc_saturated = 8
error_too_hot = 9
error_hardware_unknown = 10
error_runtime = 255

[arduino_states]
# Do not edit any of these settings unless you know what you are doing!
# ---------------------------------------------------------------------
# state_idle = Waits for requests from the PC.
# state_set_up_adcs = Picks correct ADC channels and no. of measurement
#		points.
# state_set_voltage = Sets the voltage with the DAC and triggers the
#		ADCs.
# state_change_measurement_mode = Changes the internal continuous mode.
# state_measure_adcs = Takes the measurements.
# state_adc_values_ready = Returns the measurements to the PC.
# state_autogain_adcs = Finds optimal gain for both ADCs.
# state_get_configuration = Finds current hardware configuration and
#		returns it with the firmware version.
# state_calibrate_adcs = Figures out the correct offset and calibration
#		factors for the ADCs at all gains.
# state_error = Handles errors and returns them.
# state_set_serial_nr = Takes 4 data bytes from the PC and writes them
#		to the EEPROM as a long term serial number.
state_idle = 0
state_set_up_adcs = 1
state_set_voltage = 2
state_change_measurement_mode = 3
state_measure_adcs = 4
state_adc_values_ready = 5
state_autogain_adcs = 6
state_get_configuration = 7
state_calibrate_adcs = 8
state_error = 9
state_set_serial_nr = 10

[adc_update_rate]
# Do not edit any of these settings unless you know what you are doing!
# ---------------------------------------------------------------------
# Read-out frequencies for data from the ADC in Hz. Note: 6 and 7, which
# are nominally 250 and 500 Hz, are actually not quite the nominal
# values because of the divider used internally. It appears that with
# our 2.4576 MHz quartz, 500 Hz comes from dividing by 4864 (0x1300),
# and 250 Hz from dividing by 9728 (0x2600). 50 and 60 Hz are exact,
# with dividers 49152 (0xC000) and 40960 (0xA000), respectively.
4 = 50
5 = 60
6 = 252.63157894736842105263157894737
7 = 505.26315789473684210526315789474

[serial_port_settings]
# Do not edit any of these settings unless you know what you are doing!
# ---------------------------------------------------------------------
# baud_rate, break_enabled, data_bits, date_terminal_ready,
# flow_control, parity, request_to_send, stop_bits = serial settings.
# byte_order = Endianness of messages.
# msg_start = The start marker of messages.
# msg_end = The end marker of messages.
# special_byte = All message bytes larger than special_byte are encoded
#		by splitting them into two bytes. One byte that has the value of
#		special_byte and one that is equal to the difference of the
#		original byte and special_byte. If a byte with the value of
#		special_byte is encountered it is decoded by adding it to the
#		next byte. msg_start and msg_end are not encoded.
# timeout = The time in milliseconds until a timeout occurs if no
#		further messages are received while waiting for data.
baud_rate = 400e6
break_enabled = False
data_bits = 8
data_terminal_ready = True
flow_control = NoFlowControl
parity = NoParity
request_to_send = False
stop_bits = 1
byte_order = big
msg_start = 254
msg_end = 255
special_byte = 251
timeout = 5000

[available_commands]
# Do not edit any of these settings unless you know what you are doing!
# ---------------------------------------------------------------------
# Contains the values of the various commands for the viperino.
# pc_autogain = Triggers the autogain.
# pc_calibration = Triggers the ADC calibration.
# pc_change_meas_mode = Switches between continuous and triggered
#		measurement mode.
# pc_configuration = Triggers a hardware check.
# pc_debug = Returned if the following message is a debug message.
# pc_error = Returned if an error occurred.
# pc_measure_only = Triggers a measurement without setting an energy.
# pc_ok = Returned as an acknowledgement that a message was received.
# pc_reset = Reset the controller to the state after startup.
# pc_set_serial_nr = Set the serial number of the controller.
# pc_set_up_adcs = Set the number of measurement to average over and
#		set the measured channels of the ADCs.
# pc_set_voltage = Set the voltage on the DAC and measure.
# pc_set_voltage_only = Only set the voltage on the DAC.
# pc_stop = Stop whatever the controller was doing.
pc_autogain = A
pc_calibration = C
pc_change_meas_mode = m
pc_configuration = ?
pc_debug = 252
pc_error = 253
pc_measure_only = M
pc_ok = K
pc_reset = R
pc_set_serial_nr = s
pc_set_up_adcs = S
pc_set_voltage = V
pc_set_voltage_only = v
pc_stop = x
