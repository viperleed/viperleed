[hardware_bits]
#contains the identification values of the respective hardware parts which
#   are used in the bitmask
#name = 0xValueInHex Description when bit is set
#adc_0_present = 0x01 Bit is set if ADC #0 was detected
#adc_1_present = 0x02 Bit is set if ADC #1 was detected
#lm35_present = 0x04 Bit is set if LM35 temperature sensor was detected
#relay_present = 0x08 Bit is set if the relay for I0 input 2.5V/10V is present
#jp_i0_closed = 0x10 Bit is set if JP3 7-8 is closed or relay on (to indicate 2.5V I0 range)
#jp_aux_closed = 0x20 Bit is set if JP5 is closed (to indicate 2.5V AUX range rather than 10V range)
adc_0_present = 1
adc_1_present = 2
lm35_present = 4
relay_present = 8
jp_i0_closed = 16
jp_aux_closed = 32

[error_bytes]
#error bytes which serve to identify which kind of error occurred
#error_no_error = No error
#error_serial_overflow = Hardware overflow of Arduino serial
#error_msg_too_long = Too many characters in message from PC
#error_msg_inconsistent = Message received from PC is inconsistent. Probably corrupt.
#error_msg_unknown = Unknown request from PC
#error_msg_data_invalid = Request from PC contains invalid information
#error_never_calibrated = The ADCs have never been calibrated before since bootup
#error_timeout = Timed out while waiting for something
#error_adc_saturated = One of the ADC values reached saturation, and gain can't be decreased further
#error_too_hot = The temperature read by the LM35 is too high
#error_hardware_unknown = The PC never asked for the hardware configuration
#error_runtime = Some function has been called from an inappropriate state. This is to flag possible bugs for future development.
error_no_error = 0
error_serial_overflow = 1
error_msg_too_long = 2
error_msg_inconsistent = 3
error_msg_unknown = 4
error_msg_data_invalid = 5
error_never_calibrated = 6
error_timeout = 7
error_adc_saturated = 8
error_too_hot = 9
error_hardware_unknown = 10
error_runtime = 255

[arduino_states]
#state_idle = Waits for requests from the PC
#state_set_up_adcs = Picks correct ADC channels and no. of measurement points
#state_set_voltage = Sets the voltage with the DAC and triggers the ADCs
#state_measure_adcs = Takes the measurements
#state_adc_values_ready = Returns the measurements to the PC
#state_autogain_adcs = Finds optimal gain for both ADCs
#state_get_configuration = Finds current hardware configuration and returns it with the firmware version
#state_calibrate_adcs = Figures out the correct offset and calibration factors for the ADCs at all gains.
#state_error = Handles errors and returns them
state_idle = 0
state_set_up_adcs = 1
state_set_voltage = 2
state_measure_adcs = 4
state_adc_values_ready = 5
state_autogain_adcs = 6
state_get_configuration = 7
state_calibrate_adcs = 8
state_error = 9

[adc_update_rate]
4 = 50
5 = 60
6 = 250
7 = 500

[energy_calibration]
# calibration curve for energy. use numpy.polynomial.polynomial.polynomial
# as p = Polynomial(coefficients, domain=domain, window=domain). Then
# one should call set_voltage_and_measure(p(desired_true_energy))
coefficients = [1, 0]
domain = (-10, 1100)

[measurement_settings]
#num_meas_to_average = Number of measurements done before sending the value
#   to the computer. the adc values are summed up and divided with
#   num_meas_to_average to get the mean value. value which can be cast to
#   int. allowed values are from 0 - (2**16 - 1).
#	set to 1 for continuous measurements.
i0_settle_time = 900
hv_settle_time = 940
first_settle_time = 1000
v_ref_dac = 2.5
num_meas_to_average = 1
continuous_measurement_yes = 1
continuous_measurement_no = 0

[serial_port_settings]
#special_byte = encodes/decodes if one byte in message is a STARTMARKER,
#   endmarker or a special_byte. it encodes this msg_byte with 2 bytes,
#   first is the special_byte, second is special_byte - msg_byte (int, 0-255)
baud_rate = 400e6
break_enabled = False
data_bits = 8
data_terminal_ready = True
flow_control = NoFlowControl
parity = NoParity
request_to_send = False
stop_bits = 1
byte_order = big
msg_start = 254
msg_end = 255
special_byte = 252
timeout = 5000

[available_commands]
pc_configuration = ?
pc_set_up_adcs = S
pc_ok = K
pc_reset = R
pc_set_voltage = V
pc_autogain = A
pc_error = 253
pc_calibration = C
pc_measure_only = M
pc_change_meas_mode = m
pc_stop = x
pc_set_voltage_only = v

[controller]
# contains information needed for the operation of the controller
# ------------------------------------------------
# controller_class = name of the class used for the controller
# serial_port_class = name of the class used for the serial port
# port_name = has to be determined when selecting the devices that are going
# 	to be used (can be saved to automatically try to find a device)
# firmware_version = version of the firmware installed on the PC
# update_rate = when supplying the adc with a master clock of 4,9MHz, allowed
#   update rates are = 4 (50Hz), 5 (60Hz), 6 (250Hz), 7 (500Hz).
# measurement_devices = contains the type of measurements each device can do
controller_class = ViPErinoController
serial_port_class = ViPErLEEDSerial
port_name = COM3
firmware_version = 0.5
update_rate = 4
measurement_devices = (('I0', 'HV'), ('Isample', 'temperature'), ('cold_junction',))
i0 = 0
hv = 1
isample = 0
temperature = 1
cold_junction = 0

