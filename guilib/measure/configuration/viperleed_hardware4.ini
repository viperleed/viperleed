[hardware_bits]
#contains the identification values of the respective hardware parts which
#   are used in the bitmask
#name = 0xValueInHex Description when bit is set
#adc_0_present = 0x01 Bit is set if ADC #0 was detected
#adc_1_present = 0x02 Bit is set if ADC #1 was detected
#lm35_present = 0x04 Bit is set if LM35 temperature sensor was detected
#relay_present = 0x08 Bit is set if the relay for I0 input 2.5V/10V is present
#jp_i0_closed = 0x10 Bit is set if JP3 7-8 is closed or relay on (to indicate 2.5V I0 range)
#jp_aux_closed = 0x20 Bit is set if JP5 is closed (to indicate 2.5V AUX range rather than 10V range)
adc_0_present = 1
adc_1_present = 2
lm35_present = 4
relay_present = 8
jp_i0_closed = 16
jp_aux_closed = 32

[error_bytes]
#error bytes which serve to identify which kind of error occurred
#error_no_error = No error
#error_serial_overflow = Hardware overflow of Arduino serial
#error_msg_too_long = Too many characters in message from PC
#error_msg_inconsistent = Message received from PC is inconsistent. Probably corrupt.
#error_msg_unknown = Unknown request from PC
#error_msg_data_invalid = Request from PC contains invalid information
#error_never_calibrated = The ADCs have never been calibrated before since bootup
#error_timeout = Timed out while waiting for something
#error_adc_saturated = One of the ADC values reached saturation, and gain can't be decreased further
#error_too_hot = The temperature read by the LM35 is too high
#error_hardware_unknown = The PC never asked for the hardware configuration
#error_runtime = Some function has been called from an inappropriate state. This is to flag possible bugs for future development.
error_no_error = 0
error_serial_overflow = 1
error_msg_too_long = 2
error_msg_inconsistent = 3
error_msg_unknown = 4
error_msg_data_invalid = 5
error_never_calibrated = 6
error_timeout = 7
error_adc_saturated = 8
error_too_hot = 9
error_hardware_unknown = 10
error_runtime = 255

[arduino_states]
#state_idle = Waits for requests from the PC
#state_set_up_adcs = Picks correct ADC channels and no. of measurement points
#state_set_voltage = Sets the voltage with the DAC and triggers the ADCs
#state_change_measurement_mode = Changes the internal continuous mode
#state_measure_adcs = Takes the measurements
#state_adc_values_ready = Returns the measurements to the PC
#state_autogain_adcs = Finds optimal gain for both ADCs
#state_get_configuration = Finds current hardware configuration and returns it with the firmware version
#state_calibrate_adcs = Figures out the correct offset and calibration factors for the ADCs at all gains.
#state_error = Handles errors and returns them
#state_set_serial_nr = Takes 4 data bytes from the PC and writes them to the EEPROM as a long term serial number
state_idle = 0
state_set_up_adcs = 1
state_set_voltage = 2
state_change_measurement_mode = 3
state_measure_adcs = 4
state_adc_values_ready = 5
state_autogain_adcs = 6
state_get_configuration = 7
state_calibrate_adcs = 8
state_error = 9
state_set_serial_nr = 10

[adc_update_rate]
# Read-out frequencies for data from the ADC. Note: 6 and 7, which
# are nominally 250 and 500 Hz, are actually not quite the nominal
# values because of the divider used internally. It appears that with
# our 2.4576 MHz quartz, 500 Hz comes from dividing by 4864 (0x1300),
# and 250 Hz from dividing by 9728 (0x2600). 50 and 60 Hz are exact,
# with dividers 49152 (0xC000) and 40960 (0xA000), respectively.
4 = 50
5 = 60
6 = 252.63157894736842105263157894737
7 = 505.26315789473684210526315789474

[energy_calibration]
# calibration curve for energy. use numpy.polynomial.polynomial.polynomial
# as p = Polynomial(coefficients, domain=domain, window=domain). Then
# one should call set_voltage_and_measure(p(desired_true_energy))
coefficients = [0, 1]
domain = (-10, 1100)

[measurement_settings]
#num_meas_to_average = Number of measurements done before sending the value
#   to the computer. the adc values are summed up and divided with
#   num_meas_to_average to get the mean value. value which can be cast to
#   int. allowed values are from 0 - (2**16 - 1).
#	set to 1 for continuous measurements.
i0_settle_time = 0
hv_settle_time = 0
first_settle_time = 1000
v_ref_dac = 2.5
num_meas_to_average = 10

[serial_port_settings]
#special_byte = encodes/decodes if one byte in message is a STARTMARKER,
#   endmarker or a special_byte. it encodes this msg_byte with 2 bytes,
#   first is the special_byte, second is special_byte - msg_byte (int, 0-255)
baud_rate = 400e6
break_enabled = False
data_bits = 8
data_terminal_ready = True
flow_control = NoFlowControl
parity = NoParity
request_to_send = False
stop_bits = 1
byte_order = big
msg_start = 254
msg_end = 255
special_byte = 252
timeout = 5000

[available_commands]
pc_configuration = ?
pc_set_up_adcs = S
pc_ok = K
pc_reset = R
pc_set_voltage = V
pc_autogain = A
pc_error = 253
pc_calibration = C
pc_measure_only = M
pc_change_meas_mode = m
pc_stop = x
pc_set_voltage_only = v
pc_set_serial_nr = s

[controller]
# contains information needed for the operation of the controller
# ------------------------------------------------
# controller_class = name of the class used for the controller
# serial_port_class = name of the class used for the serial port
# port_name = has to be determined when selecting the devices that are going
# 	to be used (can be saved to automatically try to find a device)
# firmware_version = version of the firmware installed on the PC
# update_rate = when supplying the adc with a master clock of 4,9MHz, allowed
#   update rates are = 4 (50Hz), 5 (60Hz), 6 (250Hz), 7 (500Hz).
# initial_delay = time the controller will need to return the first
#	measurement in a time resolved measurement
# measurement_devices = contains the type of measurements each device can do.
#   'Aux' is an alternative to 'Temperature' in case no thermocouple is
#   connected (in which case also 'Cold_Junction' is probably not useful
#   or not present)
controller_class = ViPErinoController
serial_port_class = ViPErLEEDSerial
port_name = COM4
firmware_version = 0.5
update_rate = 4
measurement_devices = (('I0', 'Measured_Energy'), ('I_Sample', 'Temperature'), ('Cold_Junction',))
i0 = 0
measured_energy = 1
i_sample = 0
temperature = 1
aux = 1
cold_junction = 0

[conversions]
# This section contains information on which types of conversions are
# to be used to transform the measurements provided by the Arduino
# unit (typically in volts or millivolts) and the physical units.
#
# i0_gain : V/uA in 0--10V range; mV/uA in 0--2.5V range
#     The value returned by the Arduino in the two ranges assumes
#     that (0--10V) 1uA produces 1V at the BNC, or (0--2.5V) 1mA
#     produces 1V at the BNC. This gain factor can be used to account
#     for other situations (e.g., a different resistor is used)
# thermocouple_type : one of the types (e.g., K) for which coefficients
#     are available in classes/thermocouple_coefficients.txt. This is
#     the quantity used to convert the thermoelectric voltage of a
#     thermocouple connected to CH1 of ADC1 (normally AUX), as well as
#     the cold-junction temperature measured by the LM35, into an actual
#     TEMPERATURE in Â°C.
i0_gain = 1
thermocouple_type = K
