"""Module folder of viperleed.calc.bookkeeper.history.

Defines the HistoryFolder class, a collection of information
concerning a single folder in the history directory.
"""

__authors__ = (
    'Michele Riva (@michele-riva)',
    )
__copyright__ = 'Copyright (c) 2019-2024 ViPErLEED developers'
__created__ = '2024-10-14'
__license__ = 'GPLv3+'

from pathlib import Path
import shutil

from viperleed.calc.lib.dataclass_utils import frozen
from viperleed.calc.lib.dataclass_utils import non_init_field
from viperleed.calc.lib.dataclass_utils import set_frozen_attr

from ..constants import HISTORY_FOLDER_RE
from ..log import LOGGER
from ..utils import make_property
from .errors import MetadataMismatchError
from .meta import BookkeeperMetaFile


@frozen
class IncompleteHistoryFolder:
    """A history folder that may contain incomplete information.

    The primary difference with respect to a "finalized" HistoryFolder
    is that an IncompleteHistoryFolder may still have files and folders
    added to it. As such, it does not contain the metadata file nor
    has means to discern whether it is a "primary" folder (i.e.,
    created from files/folders in the bookkeeper's cwd that were
    generated by calc) or a workhistory-derived one.
    """

    path: Path

    # Attributes computed during __post_init__
    tensor_num: int = non_init_field()
    job_num: int = non_init_field()

    name = make_property('path.name')

    def __post_init__(self):
        """Set up non-initialization attributes from the path given."""
        self._analyze_path()

    @property
    def exists(self):
        """Return whether this directory is present in history."""
        return self.path.is_dir()

    def copy_file_or_directory(self, file_path, with_name=None):
        """Copy `file_path` to this folder (optionally `with_name`)."""
        dest_name = with_name or file_path.name
        copy = shutil.copy2 if file_path.is_file() else shutil.copytree
        try:
            copy(file_path, self.path / dest_name)
        except OSError:
            LOGGER.error(f'Failed to copy {file_path.name} to history.')

    def _analyze_path(self):
        """Collect information from the history folder at self.path."""
        path = self.path
        match_ = HISTORY_FOLDER_RE.fullmatch(path.name)
        if not match_:
            raise ValueError(
                f'Invalid history folder {path.name} at {path.parent}. '
                f'Does not match {HISTORY_FOLDER_RE.pattern}'
                )
        set_frozen_attr(self, 'tensor_num', int(match_['tensor_num']))
        set_frozen_attr(self, 'job_num', int(match_['job_num']))


@frozen
class HistoryFolder(IncompleteHistoryFolder):
    """A collection of information concerning a folder in history."""

    metadata: BookkeeperMetaFile = non_init_field()  # At __post_init__

    parent = make_property('metadata.parent')
    hash_ = make_property('metadata.hash_')

    @property
    def has_metadata(self):
        """Return whether this folder contains a metadata file."""
        # pylint: disable-next=no-member    # It's a BookkeeperMetaFile
        return self.metadata.path.is_file()

    def check_metadata(self):
        """Raise a MetadataMismatchError if the metadata file is outdated."""
        new_meta = BookkeeperMetaFile(self.path)
        new_meta.compute_hash()
        # pylint: disable-next=no-member    # It's a BookkeeperMetaFile
        self_hash = self.metadata.hash_
        if new_meta.hash_ != self_hash:
            raise MetadataMismatchError(
                f'The metadata file in {self.path.name} has a different id'
                f'({self_hash}) than the one calculated from the contents '
                f'({new_meta.hash_}. This means that either the folder name '
                'or its contents were modified.'
                )

    def _analyze_path(self):
        """Collect information from the history folder at self.path."""
        if not self.path.is_dir():
            raise ValueError(f'{self.path} is not a directory')
        super()._analyze_path()
        set_frozen_attr(self, 'metadata', BookkeeperMetaFile(self.path))
        try:
            self.metadata.read()  # pylint: disable=no-member  # Inference
        except FileNotFoundError:
            LOGGER.warning(f'No metadata file found at {self.path}.')           # TODO: fixup if not .has_metadata
            # pylint: disable-next=no-member  # It's BookkeeperMetaFile
            self.metadata.compute_hash()   # Don't write to file though
