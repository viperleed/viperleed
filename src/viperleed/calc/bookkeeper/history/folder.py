"""Module folder of viperleed.calc.bookkeeper.history.

Defines the HistoryFolder class, a collection of information
concerning a single folder in the history directory.
"""

__authors__ = (
    'Michele Riva (@michele-riva)',
    )
__copyright__ = 'Copyright (c) 2019-2024 ViPErLEED developers'
__created__ = '2024-10-14'
__license__ = 'GPLv3+'

from enum import Enum
from pathlib import Path
import shutil

from viperleed.calc.lib.dataclass_utils import frozen
from viperleed.calc.lib.dataclass_utils import non_init_field
from viperleed.calc.lib.dataclass_utils import set_frozen_attr

from ..constants import HISTORY_FOLDER_RE
from ..log import LOGGER
from ..mode import BookkeeperMode as Mode
from ..utils import make_property
from .errors import CantRemoveEntryError
from .errors import MetadataMismatchError
from .meta import BookkeeperMetaFile


class FolderFixAction(Enum):
    """Fixing action performed on a history folder in --fix mode."""

    ADD_METADATA = (
        'Note that it is not possible to determine whether folders to which '
        'metadata files were added were created together with others during '
        'the same viperleed.calc execution. This may have an impact on how '
        'these folders are discarded or analyzed.'
        )


@frozen
class IncompleteHistoryFolder:
    """A history folder that may contain incomplete information.

    The primary difference with respect to a "finalized" HistoryFolder
    is that an IncompleteHistoryFolder may still have files and folders
    added to it. As such, it does not contain the metadata file nor
    has means to discern whether it is a "primary" folder (i.e.,
    created from files/folders in the bookkeeper's cwd that were
    generated by calc) or a workhistory-derived one.
    """

    path: Path

    # Attributes computed during __post_init__
    tensor_num: int = non_init_field()
    job_num: int = non_init_field()

    name = make_property('path.name')

    def __post_init__(self):
        """Set up non-initialization attributes from the path given."""
        self._analyze_path()

    @property
    def exists(self):
        """Return whether this directory is present in history."""
        return self.path.is_dir()

    def copy_file_or_directory(self, file_path, with_name=None):
        """Copy `file_path` to this folder (optionally `with_name`)."""
        dest_name = with_name or file_path.name
        copy = shutil.copy2 if file_path.is_file() else shutil.copytree
        try:
            copy(file_path, self.path / dest_name)
        except OSError:
            err_msg = f'Failed to copy {file_path.name}'
            if with_name:
                err_msg += f' as {dest_name}'
            err_msg += ' to history.'
            LOGGER.error(err_msg)

    def _analyze_path(self):
        """Collect information from the history folder at self.path."""
        path = self.path
        match_ = HISTORY_FOLDER_RE.fullmatch(path.name)
        if not match_:
            raise ValueError(
                f'Invalid history folder {path.name} at {path.parent}. '
                f'Does not match {HISTORY_FOLDER_RE.pattern}'
                )
        set_frozen_attr(self, 'tensor_num', int(match_['tensor_num']))
        set_frozen_attr(self, 'job_num', int(match_['job_num']))


@frozen
class HistoryFolder(IncompleteHistoryFolder):
    """A collection of information concerning a folder in history."""

    metadata: BookkeeperMetaFile = non_init_field()  # At __post_init__

    parent = make_property('metadata.parent')
    hash_ = make_property('metadata.hash_')

    @property
    def has_metadata(self):
        """Return whether this folder contains a metadata file."""
        # pylint: disable-next=no-member    # It's a BookkeeperMetaFile
        return self.metadata.file.is_file()

    def check_consistent_with_entry(self, entry):
        """Raise unless this folder is consistent with a history.info entry."""
        # Folder names should match
        entry_folder_name = entry.folder_name.value.strip()
        if self.name != entry_folder_name:
            raise CantRemoveEntryError(
                f'Folder names differ: directory name is {self.name!r}, '
                f'history.info entry has {entry_folder_name!r} instead.'
                )
        # Tensor numbers too
        entry_tensors = ((0,) if entry.tensor_nums.no_tensors
                         else entry.tensor_nums.value)
        if self.tensor_num not in entry_tensors:
            raise CantRemoveEntryError(
                f'Tensor number from folder name ({self.tensor_num}) is not '
                f'among the ones in the history.info entry {entry_tensors}'
                )
        # And the same for the job ids
        if self.job_num not in entry.job_nums.value:
            raise CantRemoveEntryError(
                f'Job number from folder name ({self.job_num}) is not among '
                f'the ones in the history.info entry {entry.job_nums.value}'
                )

    def check_metadata(self):
        """Raise a MetadataMismatchError if the metadata file is outdated."""
        new_meta = BookkeeperMetaFile(self.path)
        new_meta.compute_hash()
        # pylint: disable-next=no-member    # It's a BookkeeperMetaFile
        self_hash = self.metadata.hash_
        if new_meta.hash_ != self_hash:
            raise MetadataMismatchError(
                f'The metadata file in {self.path.name} has a different id'
                f'({self_hash}) than the one calculated from the contents '
                f'({new_meta.hash_}. This means that either the folder name '
                'or its contents were modified.'
                )

    def fix(self):
        """Fix the contents of this folder. Return a set of fix actions."""
        fix_actions = set()
        if not self.has_metadata:
            LOGGER.info(f'Adding metadata file in folder {self.path.name}.')
            # pylint: disable-next=no-member  # It's BookkeeperMetaFile
            self.metadata.write()
            fix_actions.add(FolderFixAction.ADD_METADATA)
        return fix_actions

    def _analyze_path(self):
        """Collect information from the history folder at self.path."""
        if not self.path.is_dir():
            raise ValueError(f'{self.path} is not a directory')
        super()._analyze_path()
        set_frozen_attr(self, 'metadata', BookkeeperMetaFile(self.path))
        try:
            self.metadata.read()  # pylint: disable=no-member  # Inference
        except FileNotFoundError:
            folder_name = f'{self.path.parent.name}/{self.path.name}'
            LOGGER.warning(
                f'No metadata file found in {folder_name}. '
                f'Consider running bookkeeper {Mode.FIX.long_flag}.'
                )
            # pylint: disable-next=no-member  # It's BookkeeperMetaFile
            self.metadata.compute_hash()   # Don't write to file though
