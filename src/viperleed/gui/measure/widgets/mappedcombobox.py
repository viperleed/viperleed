"""Module mappedcombobox of viperleed.gui.measure.widgets.

Defines the MappedComboBox class: a QComboBox whose items can be
accessed by name or by data.
"""

__authors__ = (
    'Michele Riva (@michele-riva)',
    )
__copyright__ = 'Copyright (c) 2019-2025 ViPErLEED developers'
__created__ = '2022-10-20'
__license__ = 'GPLv3+'

from PyQt5 import QtCore as qtc
from PyQt5 import QtWidgets as qtw


_NO_SELECTION = "** Please select **"


class MappedComboBox(qtw.QComboBox):
    """A QComboBox with easy access to item data.

    Used if one wants to show a certain text but store more
    complex data under the hood.
    """

    current_data_changed = qtc.pyqtSignal(object)

    def __init__(self, mapper, **kwargs):
        """Initialize instance.

        Parameters
        ----------
        mapper : callable
            A callable that should take a sequence of objects and
            return (display_text, stored_data) for each of them.
            The map generated by mapper(items) should be bijective,
            i.e., it should always map one key to one value.
        **kwargs : object, optional
            Extra keyword arguments passed to QComboBox.

        Raises
        ------
        ValueError
            If neither text_to_value_map nor value_to_text_map are
            given or if both are.
        ValueError
            If values in text_to_value_map (or value_to_text_map)
            are not unique, i.e., the map is not bijective.
        """
        self._value_to_text = {}
        self._text_to_value = {}
        self._mapper = mapper

        super().__init__(**kwargs)
        self.currentIndexChanged.connect(self.__on_index_changed)

    def set_current_data(self, data):
        """Set current selection to data."""
        text = self._value_to_text.get(data, _NO_SELECTION)
        self.setCurrentText(text)

    def addItem(self, item):             # pylint: disable=invalid-name
        """Add an entry from item."""
        text, data = self._mapper((item,))
        self._value_to_text[data] = text
        self._text_to_value[text] = data
        if len(self._value_to_text) != len(self._text_to_value):
            raise ValueError(f"Mapper is not bijective for {item}.")
        super().addItem(text, usserData=data)

    def addItems(self, items):           # pylint: disable=invalid-name
        """Add multiple entries from items."""
        text_value = dict(self._mapper(items))
        value_text = {v: k for k, v in text_value.items()}
        if len(text_value) != len(value_text):
            raise ValueError(f"Mapper is not bijective for one of {items}")

        old_len = len(self._value_to_text)
        self._value_to_text.update(value_text)
        self._text_to_value.update(text_value)
        if len(self._value_to_text) != old_len + len(value_text):
            raise ValueError(f"Some items in {items} were already present.")

        super().addItems(text_value)
        for idx, data in enumerate(self._text_to_value.values()):
            self.setItemData(idx, data)

    def clear(self):
        """Remove all items from self."""
        self._value_to_text.clear()
        self._text_to_value.clear()
        super().clear()

    def removeItem(self, index):         # pylint: disable=invalid-name
        """Remove item at index."""
        if not 0 <= index < self.count():
            raise IndexError(f"Index {index} out of range")
        data = self._text_to_value.pop(self.itemText(index))
        self._value_to_text.pop(data)
        super().removeItem(index)

    def __on_index_changed(self, idx):
        """Emit current_data_changed upon selection."""
        if idx < 0:  # Box empty
            return
        self.current_data_changed.emit(self.itemData(idx))
