[hardware_bits]
#contains the identification values of the respective hardware parts which
#   are used in the bitmask
#name = 0xValueInHex Description when bit is set
#adc_0_present = 0x01 Bit is set if ADC #0 was detected
#adc_1_present = 0x02 Bit is set if ADC #1 was detected
#lm35_present = 0x04 Bit is set if LM35 temperature sensor was detected
#relay_present = 0x08 Bit is set if the relay for I0 input 2.5V/10V is present
#jp_i0_closed = 0x10 Bit is set if JP3 7-8 is closed or relay on (to indicate 2.5V I0 range)
#jp_aux_closed = 0x20 Bit is set if JP5 is closed (to indicate 2.5V AUX range rather than 10V range)
adc_0_present = 1
adc_1_present = 2
lm35_present = 4
relay_present = 8
jp_i0_closed = 16
jp_aux_closed = 32

[error_bytes]
#error bytes which serve to identify which kind of error occurred
#error_no_error = No error
#error_serial_overflow = Hardware overflow of Arduino serial
#error_msg_too_long = Too many characters in message from PC
#error_msg_inconsistent = Message received from PC is inconsistent. Probably corrupt.
#error_msg_unknown = Unknown request from PC
#error_msg_data_invalid = Request from PC contains invalid information
#error_never_calibrated = The ADCs have never been calibrated before since bootup
#error_timeout = Timed out while waiting for something
#error_adc_saturated = One of the ADC values reached saturation, and gain can't be decreased further
#error_too_hot = The temperature read by the LM35 is too high
#error_hardware_unknown = The PC never asked for the hardware configuration
#error_runtime = Some function has been called from an inappropriate state. This is to flag possible bugs for future development.
error_no_error = 0
error_serial_overflow = 1
error_msg_too_long = 2
error_msg_inconsistent = 3
error_msg_unknown = 4
error_msg_data_invalid = 5
error_never_calibrated = 6
error_timeout = 7
error_adc_saturated = 8
error_too_hot = 9
error_hardware_unknown = 10
error_runtime = 255

[arduino_states]
#state_idle = Waits for requests from the PC
#state_set_up_adcs = Picks correct ADC channels and no. of measurement points
#state_set_voltage = Sets the voltage with the DAC and triggers the ADCs
#state_change_measurement_mode = Changes the internal continuous mode
#state_measure_adcs = Takes the measurements
#state_adc_values_ready = Returns the measurements to the PC
#state_autogain_adcs = Finds optimal gain for both ADCs
#state_get_configuration = Finds current hardware configuration and returns it with the firmware version
#state_calibrate_adcs = Figures out the correct offset and calibration factors for the ADCs at all gains.
#state_error = Handles errors and returns them
#state_set_serial_nr = Takes 4 data bytes from the PC and writes them to the EEPROM as a long term serial number
state_idle = 0
state_set_up_adcs = 1
state_set_voltage = 2
state_change_measurement_mode = 3
state_measure_adcs = 4
state_adc_values_ready = 5
state_autogain_adcs = 6
state_get_configuration = 7
state_calibrate_adcs = 8
state_error = 9
state_set_serial_nr = 10

[adc_update_rate]
4 = 50
5 = 60
6 = 250
7 = 500

[energy_calibration]
# calibration curve for energy. use numpy.polynomial.polynomial.polynomial
# as p = Polynomial(coefficients, domain=domain, window=domain). Then
# one should call set_voltage_and_measure(p(desired_true_energy))
coefficients = [0, 1]
domain = (-10, 1100)

[measurement_settings]
#num_meas_to_average = Number of measurements done before sending the value
#   to the computer. the adc values are summed up and divided with
#   num_meas_to_average to get the mean value. value which can be cast to
#   int. allowed values are from 0 - (2**16 - 1).
#	set to 1 for continuous measurements.
i0_settle_time = 0
hv_settle_time = 0
first_settle_time = 1000
v_ref_dac = 2.5
num_meas_to_average = 10
continuous_measurement_yes = 1
continuous_measurement_no = 0

[serial_port_settings]
#special_byte = encodes/decodes if one byte in message is a STARTMARKER,
#   endmarker or a special_byte. it encodes this msg_byte with 2 bytes,
#   first is the special_byte, second is special_byte - msg_byte (int, 0-255)
baud_rate = 400e6
break_enabled = False
data_bits = 8
data_terminal_ready = True
flow_control = NoFlowControl
parity = NoParity
request_to_send = False
stop_bits = 1
byte_order = big
msg_start = 254
msg_end = 255
special_byte = 252
timeout = 5000

[available_commands]
pc_configuration = ?
pc_set_up_adcs = S
pc_ok = K
pc_reset = R
pc_set_voltage = V
pc_autogain = A
pc_error = 253
pc_calibration = C
pc_measure_only = M
pc_change_meas_mode = m
pc_stop = x
pc_set_voltage_only = v
pc_set_serial_nr = s

[controller]
# contains information needed for the operation of the controller
# ------------------------------------------------
# controller_class = name of the class used for the controller
# serial_port_class = name of the class used for the serial port
# port_name = has to be determined when selecting the devices that are going
# 	to be used (can be saved to automatically try to find a device)
# firmware_version = version of the firmware installed on the PC
# update_rate = when supplying the adc with a master clock of 4,9MHz, allowed
#   update rates are = 4 (50Hz), 5 (60Hz), 6 (250Hz), 7 (500Hz).
# initial_delay = time the controller will need to return the first
#	measurement in a time resolved measurement
# measurement_devices = contains the type of measurements each device can do
controller_class = ViPErinoController
serial_port_class = ViPErLEEDSerial
port_name = COM10
firmware_version = 0.6
update_rate = 4
; initial_delay = 0
measurement_devices = (('I0', 'Measured_Energy'), ('I_Sample', 'Temperature'), ('Cold_Junction',))
I0 = 0
Measured_Energy = 1
I_Sample = 0
Temperature = 1
Cold_Junction = 0
